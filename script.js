"use strict";

// DEFAULT PARAMETERS

/* Le code d√©clare une fonction appel√©e createBooking qui prend 
en param√®tre trois arguments : flightNum, numPassengers et price. 
La fonction cr√©e ensuite un objet avec ces 3 propri√©t√©s et l'affiche 
dans la console avant de le pousser dans un tableau appel√© bookings.

Le second param√®tre, numPassengers, est par d√©faut √† 1 si non pr√©cis√©. 
De m√™me, le troisi√®me param√®tre, price, est mis √† 199 * numPassengers 
par d√©faut s'il n'est pas sp√©cifi√©.

Le code appelle la fonction createBooking quatre fois avec diff√©rentes 
combinaisons d'arguments. Dans la derni√®re invocation, nous fournissons 
seulement une valeur pour flightNum et nous laissons les deux autres param√®tres 
√† leurs valeurs par d√©faut, i.e. undefined. Cet appel sera √©quivalent √† 
celui-ci : createBooking("LH123", 1, 199); 
o√π numPassengers et price sont calcul√©s √† partir de leurs valeurs par d√©faut. */

// Initialize an empty array to store bookings
const bookings = [];

// Create a function called createBooking that accepts three parameters, with the last two having default values.
const createBooking = function (flightNum, numPassengers = 1, price = 199) {
    // ES5 Syntax (used before ES6):
    // numPassengers = numPassengers || 1;
    // price = price || 199;

    // Create a booking object with the provided or default parameters
    const booking = {
        flightNum,
        numPassengers,
        price,
    };

    // Print the booking object to the console
    console.log(booking);

    // Add the booking object to the bookings array
    bookings.push(booking);
};

// Call the createBooking function with different sets of arguments to test its behavior
createBooking("LH123"); // prints {flightNum: "LH123", numPassengers: 1, price: 199} and adds the object to the bookings array
createBooking("LH123", 2, 800); // prints {flightNum: "LH123", numPassengers: 2, price: 800} and adds the object to the bookings array
createBooking("LH123", 2); // prints {flightNum: "LH123", numPassengers: 2, price: 199} and adds the object to the bookings array
createBooking("LH123", 5); // prints {flightNum: "LH123", numPassengers: 5, price: 199} and adds the object to the bookings array
createBooking("LH123", undefined, 1000); // prints {flightNum: "LH123", numPassengers: 1, price: 1000} and adds the object to the bookings array (using undefined as a placeholder for the second argument)

// -------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------

// How passing arg works: Value vs reference

/* Cet exemple de code montre comment le passage d'une valeur, 
comme un type de donn√©es primitif - dans ce cas "LH234" en tant 
que variable flight - fonctionne diff√©remment du passage d'une r√©f√©rence, 
telle qu'un objet avec des propri√©t√©s telles que jonas dans l'exemple ci-dessous.

Lors du passage d'une valeur, la fonction prendra une copie de cette valeur 
et les modifications apport√©es √† celle-ci n'affecteront pas la variable originale 
en dehors de la fonction. Cela s'appelle ¬´ passer par valeur ¬ª.

Lorsqu'une r√©f√©rence est pass√©e, la fonction prendra une r√©f√©rence (un pointeur) √† 
l'objet original et les modifications apport√©es √† celui-ci dans le corps de la fonction 
seront refl√©t√©es dans la copie originale de l'objet en dehors de la fonction. 
Cela s'appelle ¬´ passer par r√©f√©rence ¬ª.

Dans l'exemple, nous voyons les deux techniques utilis√©es. Le num√©ro de vol est transmis 
sous forme de cha√Æne standard et ensuite modifi√© dans le corps de la fonction, 
mais √©tant donn√© que les cha√Ænes sont un type de donn√©es primitives, la valeur originale 
reste inchang√©e en dehors du corps de la fonction.

Cependant, l'objet jonas est pass√© par r√©f√©rence. Lorsque la fonction modifie la propri√©t√© nom, 
elle affecte l'objet original dans le contexte global, et les changements sont visibles en dehors 
du corps de la fonction. De plus, le num√©ro de passeport est g√©n√©r√© al√©atoirement √† l'aide d'une 
nouvelle fonction de passeport, o√π l'objet jonas est pass√© par r√©f√©rence et donc les changements 
dans la propri√©t√© passeport sont √©galement visibles dans le contexte global. */

// D√©claration de la variable flight avec la valeur 'LH234'
const flight = "LH234";

// D√©claration d'un objet jonas avec deux propri√©t√©s : name et passport
const jonas = {
    name: "Jonas Schmedtmann",
    passport: 24739479284,
};

// D√©claration d'une fonction checkIn avec deux param√®tres : flightNum et passenger
const checkIn = function (flightNum, passenger) {
    // La valeur de flightNum est chang√©e √† 'LH999'
    flightNum = "LH999";
    // La propri√©t√© name de l'objet passenger est modifi√©e en ajoutant 'Mr. ' au d√©but
    passenger.name = "Mr. " + passenger.name;

    // V√©rification que le num√©ro de passeport du passager correspond √† la valeur attendue
    if (passenger.passport === 24739479284) {
        console.log("Checked in");
    } else {
        console.log("Wrong passport!");
    }
};

// Appel de la fonction checkIn avec les arguments flight et jonas
// checkIn(flight, jonas);

// Affichage de la valeur de la variable flight dans la console
// console.log(flight);

// Affichage de l'objet jonas dans la console
// console.log(jonas);

// La partie suivante est un commentaire qui explique ce qui se passe dans le code ci-dessus
// C'est la m√™me chose que de faire...
// const flightNum = flight;
// const passenger = jonas;

// D√©claration d'une fonction newPassport avec un param√®tre person
const newPassport = function (person) {
    // La propri√©t√© passport de l'objet person est modifi√©e avec une valeur al√©atoire entre 0 et 100000 (arrondie √† l'entier inf√©rieur)
    person.passport = Math.trunc(Math.random() * 100000);
};

// Appel de la fonction newPassport avec l'objet jonas comme argument
newPassport(jonas);

// Appel de la fonction checkIn avec les arguments flight et jonas (qui a maintenant un nouveau num√©ro de passeport)
checkIn(flight, jonas);

// -------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------

// Fonctions accepting Callback Functions

/* Ce code illustre comment utiliser des fonction callback en JavaScript. 
La fonction transformer() est une fonction de haut niveau - elle prend en 
compte deux arguments, la cha√Æne et une fonction callback. Cette fonction 
ex√©cutera alors la fonction callback donn√©e sur la cha√Æne, retournant une 
version transform√©e de l'argument d'entr√©e.

Les fonctions oneWord() et upperFirstWord() sont toutes deux des fonctions callback. 
Dans cet exemple, upperFirstWord() mettra en majuscule le premier mot de la cha√Æne d'entr√©e, 
tandis que oneWord() transformera la cha√Æne compl√®te en un mot en minuscules (en rempla√ßant tous les espaces par rien).

Enfin, high5() est un autre exemple de callback qui sera ex√©cut√© √† plusieurs reprises, 
par exemple dans une boucle. Dans ce cas particulier, lorsque le corps du document est 
cliqu√© ou lorsqu‚Äôun tableau de noms est it√©r√© dans une boucle, la fonction callback high5() est invoqu√©e. */

// Cette fonction prend une cha√Æne de caract√®res et renvoie une version en minuscules sans espaces
const oneWord = function (str) {
    return str.replaceAll(" ", " ").toLowerCase();
};

// Cette fonction prend une cha√Æne de caract√®res et renvoie une version avec le premier mot en majuscule pour chaque mot
const upperFirstWord = function (str) {
    const [first, ...others] = str.split(" ");
    return [first.toUpperCase(), ...others].join(" ");
};

// Cette fonction prend une cha√Æne de caract√®res et une fonction de transformation, applique la fonction de transformation √† la cha√Æne de caract√®res, puis affiche la cha√Æne de caract√®res d'origine, la cha√Æne transform√©e et le nom de la fonction de transformation utilis√©e
const transformer = function (str, fn) {
    console.log(`Original string: ${str}`);
    console.log(`Transform string ${fn(str)}`);
    console.log(`Transformed by: ${fn.name}`);
};

// Applique la fonction upperFirstWord √† la cha√Æne de caract√®res 'JavaScript is the best!' et affiche le r√©sultat
transformer("JavaScript is the best!", upperFirstWord);

// Applique la fonction oneWord √† la cha√Æne de caract√®res 'JavaScript is the best!' et affiche le r√©sultat
transformer("JavaScript is the best!", oneWord);

// D√©clare une fonction high5 qui affiche un emoji "rock on" dans la console
const high5 = function () {
    console.log("ü§ü");
};

// Attache la fonction high5 √† l'√©v√©nement click du corps du document, de sorte que chaque clic sur le corps du document affiche l'emoji "rock on" dans la console
document.body.addEventListener("click", high5);

// Applique la fonction high5 √† chaque √©l√©ment du tableau ['Jonas', 'Martha', 'Adam'], de sorte que chaque √©l√©ment affiche l'emoji "rock on" dans la console
["Jonas", "Martha", "Adam"].forEach(high5);

// -------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------

// Functions returning functions

/* Cet exemple de code montre diff√©rentes fa√ßons de d√©finir des fonctions 
qui retournent d'autres fonctions en JavaScript.

La premi√®re exemple, greet, est une d√©claration de fonction normale o√π la 
fonction interne prend un argument appel√© name. Il affiche ensuite une phrase 
√† l'aide d'une interpolation de cha√Æne (${greeting} ${name}) o√π greeting est 
l'argument pass√© √† la fonction externe et name est l'argument pass√© √† la fonction interne. 
La fonction peut √™tre appel√©e avec deux arguments de cette fa√ßon : greet("Hello")("John"). 
Cela entra√Æne Hello John √©tant affich√© dans la console.

Le second exemple, greet2, fait la m√™me chose que le pr√©c√©dent, mais utilise 
des fl√®ches √† la place. Les fonctions fl√®ches sont plus simples √† lire, mais 
produisent le m√™me r√©sultat.

Le troisi√®me exemple, greetArr, simplifie encore les choses. Il n√©cessite seulement 
un argument, qui est pass√© √† la fonction externe, et profite du retour implicite que 
les fonctions √† fl√®che ont. Il peut √™tre invoqu√© de cette fa√ßon : greetArr("Yow")("la cit√©"), 
entra√Ænant ¬´ Yow la cit√© ¬ª √©tant affich√© dans la console.

Enfin, les quelques lignes finales d√©montrent comment cr√©er une variable (greeterHey) 
qui stocke le r√©sultat de l‚Äôappel √† greet("Hey"), ce qui rend possible d'appeler directement 
la variable avec un seul argument, greeterHey("John"). */

// cr√©er une fonction qui prend un param√®tre greeting et
// retourne une fonction qui prendra un param√®tre name
const greet = function (greeting) {
    return function (name) {
        console.log(`${greeting} ${name}`);
    };
};

// Utiliser la fonction greeter avec le param√®tre 'Hey'
const greeterHey = greet("Hey");

// Appeler greeterHey avec les noms suivants en tant que param√®tres
greeterHey("Jonas");
greeterHey("Steven");

// Appeler directement greet avec le param√®tre 'Hello' et le nom Jonas
greet("Hello")("Jonas");

// La m√™me chose en utilisant des fonctions fl√©ch√©es
const greet2 = (greeting) => (name) => console.log(`${greeting} ${name}`);

// Appeler greet2  avec le param√®tre 'Hello' et le nom Eddy
greet2("Hello")("Eddy");

// -------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------

// The call and apply Methods

/* Utilisation des m√©thodes call() et apply() en JavaScript
Le code fourni montre comment utiliser les m√©thodes call() et apply() en JavaScript. 
call() et apply() sont parmi les trois m√©thodes d'invocation disponibles lors de 
l'appel d'une fonction.

La m√©thode call() prend deux arguments : le argument this (la valeur de this √† l'int√©rieur 
de la fonction appel√©e) et une liste optionnelle des param√®tres pour que la fonction les utilise. 
Dans l'exemple ci-dessus, lufthansa.book est appel√© avec call avec la valeur this d√©finie 
comme eurowings, ce qui permet d'acc√©der aux m√™mes donn√©es que lufthansa.

La m√©thode apply() prend √©galement deux arguments - le this et un tableau des valeurs des 
param√®tres - mais diff√®re du call() dans le sens o√π les param√®tres doivent √™tre mis dans 
un tableau avant de pouvoir √™tre pass√©s.

Dans l'exemple fourni, book est appel√© avec apply sur l'objet swiss, en utilisant un tableau 
contenant le num√©ro de vol et le nom de la r√©servation. Il est ensuite appel√© une fois de plus 
en utilisant l'op√©rateur spread (...) qui est essentiellement raccourci pour la m√©thode apply(). */

const lufthansa = {
    // object literal containing airline name, IATA code and an array of bookings
    airline: "Lufthansa",
    iataCode: "LH",
    bookings: [],

    // function to book a seat on a flight
    book(flightNum, name) {
        console.log(`
    ${name} booked a seat on ${this.airline} flight ${this.iataCode}${flightNum}
    `);
        // add new booking information to the bookings array
        this.bookings.push({ flight: `${this.iataCode}${flightNum}`, name });
    },
};
// example of using the book funtion
lufthansa.book(239, "Jonas Schmedtmann");
lufthansa.book(635, "John Smith");

const eurowings = {
    // create new airline with its properties
    airline: "Eurowings",
    iataCode: "EW",
    bookings: [],
};

// assign the book method from the lufthansa object to a new variable
const book = lufthansa.book;

// call the book function and pass in eurowings as the this context
book.call(eurowings, 23, "Sarah Williams"); // le premier param√®tre est l'objet vers lequel le $this pointera
console.log(eurowings);

// call the book function again but this time passing in lufthaansa as the context
book.call(lufthansa, 239, "Mary Cooper");
console.log(lufthansa);

const swiss = {
    // create new airline with its properties
    airline: "Swiss Air Lines",
    iataCode: "LX",
    bookings: [],
};

// call the book function using swiss as the context, meaning that it will update the swiss bookings array
book.call(swiss, 583, "Mary Cooper");

// use apply method to set the context of the book function to the swiss
// note that the second parameter of the apply method is an array containing the arguments to be passed into the book function
const flightData = [583, "George Cooper"];
book.apply(swiss, flightData);
console.log(swiss);

// spread operator allows us to spread/unpack elements of a given array as individual arguments
// here we are using the spread operator to pass each element of the flightData array as separate arguments for the book function
book.call(swiss, ...flightData);

// -------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------

// The bind Method

/* Le m√©thode bind() cr√©e une nouvelle fonction qui, lorsqu'elle est appel√©e, 
affecte sa cl√© this √† la valeur appropri√©e avec une s√©quence donn√©e d'arguments 
devant √™tre fournis avant ceux fournis lors de l'appel de la nouvelle fonction.

Dans le code ci-dessus, la m√©thode book.call(eurowings) est utilis√©e pour cr√©er 
une nouvelle r√©servation de vol avec Eurosowings en passant les arguments 23 
et "Sarah Williams".

Les quatre lignes suivantes, o√π bookEW, bookLH et bookLX ont √©t√© d√©clar√©s, 
utilisent la m√©thode bind() pour cr√©er une nouvelle fonction avec leur compagnie 
a√©rienne respective comme contexte.

De plus, comme les m√©thodes bind() permettent d'appliquer partiellement des arguments, 
bookEW23() peut √™tre utilis√© pour effectuer une r√©servation sur Eurowings avec le 
num√©ro du passager toujours fix√© √† 23.

La m√©thode bind() de la Lufthansa est utilis√©e pour la pr√©parer √† un √©couteur d'√©v√©nements. 
Cela assurera que le mot cl√© this fait r√©f√©rence √† l'objet Lufthansa chaque fois que le 
gestionnaire d'√©v√©nement est d√©clench√©.

Sans cette liaison, le mot cl√© fera r√©f√©rence √† l'objet responsable du d√©clenchement de 
l'√©v√©nement (probablement l'√©l√©ment DOM qui a √©t√© cliqu√©). Cela veillera √† ce que this.planes 
fasse r√©f√©rence √† la propri√©t√© appropri√©e, de mani√®re √† pouvoir √™tre incr√©ment√©e correctement.

*/

// book.call(eurowings, 23, 'Sarah Williams');

const bookEW = book.bind(eurowings); // bind the book function to the eurowings object

const bookLH = book.bind(lufthansa); // bind the book function to the lufthansa object
const bookLX = book.bind(swiss); // bind the book function to the swiss object

bookEW(23, "Steven Williams"); // call the book function using the eurowings object as the context

const bookEW23 = book.bind(eurowings, 23); // bind the book function to the eurowings object and set the flight number to 23

bookEW23("Jonas Schmedtmann"); // call the book function using the eurowings object as the context and the name 'Jonas Schmedtmann' as the second argument
bookEW23("Martha Cooper"); // call the book function using the eurowings object as the context and th

// Set the lufthansa plane count to 300
lufthansa.planes = 300;

// Define the buyPlane function which increases the number
// of planes by one and logs it to the console
lufthansa.buyPlane = function () {
    console.log(this);

    this.planes++;
    console.log(this.planes);
};

// Add event listener to the HTML element with the 'buy' class
// so each time it's clicked, the buyPlane function is invoked
document
    .querySelector(".buy")
    .addEventListener("click", lufthansa.buyPlane.bind(lufthansa));

// Partial application

/*
La focus appliqu√©e partielle vous permet de cr√©er une nouvelle fonction en 
pr√©fournissant certaines des arguments √† une fonction donn√©e. Ceci est fait 
en utilisant la m√©thode bind(), o√π le premier argument pass√© √† bind() devient 
le premier argument pour la nouvelle fonction.

Les applications partielles peuvent √©galement √™tre cr√©√©es manuellement plut√¥t 
qu'en utilisant bind(). Les lignes suivantes montrent comment faire cela en cr√©ant addVAT2

*/

// Define the addTax function which takes a rate and value and returns value + value * rate
const addTax = (rate, value) => value + value * rate;
console.log(addTax(0.1, 200));

//Define the addVAT function which uses partial application to always have rate 0.23
const addVAT = addTax.bind(null, 0.23);
//Is The Same like
//addVAT = value => value + value * 0.23;

console.log(addVAT(100));
console.log(addVAT(23));

//Define the addTaxRate function which takes in a rate and sets it in the closure scope
//The returned inner function utilizes the rate from the scope and
//calculates and returns value + value * rate
const addTaxRate = function (rate) {
    return function (value) {
        return value + value * rate;
    };
};

//Create addVAT2 by applying the addTaxRate function and passing 0.23 as the rate
const addVAT2 = addTaxRate(0.23);
console.log(addVAT2(100));
console.log(addVAT2(23));

// Coding Challenge #1

